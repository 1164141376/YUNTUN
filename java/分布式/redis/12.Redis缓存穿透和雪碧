### Redis 缓存穿透和雪崩

缓存穿透

> 概念

用户想要查询一个数据发现redis内存数据库没有，缓存没有命中，于是向持久层数据库查询，发现也没有，预算本次查询失败。当用户很多的时候，于是都去了持久层数据库，这是出现了缓存穿透

> 解决方案

#### 布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力

![image-20201119180626234](12.Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9.assets/image-20201119180626234.png)



#### 缓存空对象

当存储层不命中，即使返回的空对象也将其缓存起来，同时设置一个过期时间，保护了后端数据源

![image-20201119180757306](12.Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9.assets/image-20201119180757306.png)

这种方法有两个问题：

- 空值被缓存起来，意味着缓存需要更多的空间存储更多的键，这当中很多的空值键
- 几十对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，对于保持一致性的业务会有影响





### 缓存击穿（量太大，缓存过期！）

> 概述

这里需要注意和缓存穿透的区别，缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这个点进行访问，当这个key失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏幕上凿开一个洞！

> 解决方案

#### 设置热点数据永不过期

从缓存层面来看，没有设置过期时间，所以不会出现热点key过期产生的问题。

#### 加互斥锁

分布式锁：使用分布式锁，保证对于没个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待计科。这种方式高并发的压力转移到了分布式锁，因此对分布锁的考验很大



## 缓存雪崩

> 概念

缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机！



>  解决方案

#### redis高可用

含义：既然redis有可能挂掉，就多设置几台redis

#### 限流降级

含义：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

#### 数据预热

数据加热的含义就是在正式部署之前，我可吧可能的数据预先访问一遍，这样就将大量访问的数据加入到缓存，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。









