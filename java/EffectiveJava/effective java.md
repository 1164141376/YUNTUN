## 第1章

​		引言：

​			组件的用户不该被其行为所迷惑，组件尽可能小，单不能太小，组件指任何可以重用的软件元素（单个方法，或则多个包的复杂框架）

​		代码应该被重用、而不是被拷贝，组件之间的依赖性应该尽可能降到最小

​		

​		Java支持的四种类型：接口、类、数组、基本数据类型（前三种为引用类型）



## 第2章 创建和销毁对象

#### 	第1条：用静态工厂方法代替构造函器

​		静态工厂方法与构造器不同的第一大优势，它们有名字。**调用更加清晰**

​		第二大优势，不必每次调用它们的时候都创建一个新的对象

​		第三大优势，可以灵活的返回原返回类型的任何子类型的对象

​		第四大优势，返回对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值。

​		第五大优势，方法返回的对象所属的类，在编写包含该静态工厂方法的类的时候可以不存在。

​		第一个缺点，类如果不包含共有的或者受保护的构造器，就不能被子类化。

​		第二个缺点，程序员很难发现它们



#### 第2条：遇到多个构造器参数时要考虑使用构造器

​		如果类的构造器或者静态工厂中具有多个参数，设计这种类的时候，Builder模式是一个不错的选择



#### 第3条：用私有构造器或者枚举类强化Singleton属性

​		使类成为Singleton会使它的客户端测试变得十分困难

​		1.使Field域公有并且final

​		2.静态工厂，使Field域私有并且final提供获取实例的公共静态方法

​		3.可以编写一个泛型Singleton工厂

​		优缺点：

​		1.公有域的优势在于，API很清楚的表明了这个类是一个Singleton

​		2.静态工厂方法的优势之一在于，它提供了灵活性：在不改变API的前提下，可以改变这个类是否应该是Singleton的想法。

​			可以通过方法引用作为提供者

​		3.单元素的枚举类型经常成为实现Singleton的最佳方法，如果Singleton必须拓展一个超类，而不是拓展Enum的时候就不宜使用这个方法。

​		

#### 第4条：通过私有构造器强化不可实例化的能力

​		有的时候需要编写包含静态方法和静态域的类。这样的类不希望被实例化，在缺省构造器的情况下会自动提供一个公有、无参的缺省构造器

​		企图通过将类做成抽象类来强制该类不可被实例化是**行不通**的。

​		让这个类包含一个私有构造器，它就不能被实例化

~~~java
//Noninstantiable utility class
public class UtilityClass{
    //Suppress default constructor for noninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
 	....// Remainder omitted
}
~~~



#### 第5条：有限考虑依赖注入来引用资源

​		不要用Singleton和静态工具类实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为，也不要直接用这个类来创建这些资源，而应该将这些资源或工厂传给构造器（或者静态工厂，或者构造器），通过它们来创建类。这个就叫做依赖注入它极大的提升了类的**灵活性、可重用性和可测试性**。



#### 第6条：避免创建不必要的对象

​		要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱

​		“保护性拷贝”的情况下，重用对象的代价要比创建新的重复对象要大



#### 第7条：消除过期的对象引用

​		清空对象引用应该是一种例外，而不是一种规范行为

​		只要类是自己管理内存，程序员就应该警惕内存泄露问题

##### 		内存泄露的另一个常见来源是缓存

​		只有当所要缓存项的生命周期是由该键外部引用而不是由值决定时，WeakHashMap才有用

​		

##### 		内存泄露的第三个常见的来源是监听器和其他回调

​		

#### 第8条：避免使用终结方法和清楚方法

​		终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。

​		清除方法没有终结方法那么危险，但仍然不可预测、运行缓慢，一般情况下也是不必要的。

​		注重实践的任务不应该由终结方法或者清除方法来完成

##### 永远不应该依赖终结方法或者清除方法来更新重要的持久状态

​		使用终结方法和清楚方法有一个非常严重的性能损失



#### 第9条：try-with-resources 优先于 try-finally

## 第3章 对于所有对象都通用的方法

#### 第10条：覆盖equals时请准守通用约定

​		什么时候应该覆盖equals方法，如果类具有自己特有的“逻辑相等”概念（不同于对象相等），而且超类还没有覆盖equals，这通常属于“值类“的情形。不仅必须覆盖equals方法，而且这样做也使得这个类的实例可以被做映射表（map）的键（key）或者集合（set）的元素。		

​		覆盖equals方法的时候，必须遵循通用的约定，来自Object的规范

​		**自反性，对称性，传递性，一致性，对于任何非null的引用值x，x.equals(null)必须返回null**

​		

​		覆盖 equals 时总要覆盖 hashCode

​		不要企图让 equals 方法过于智能

​		不要将 equals 声明中的 Object 对象替换成其他类型



​		编写和测试 equals（及 hashCode）  方法都是十分繁琐的，得到的代码也很琐碎，代替手工编写和测试这些方法的最佳途径，是使用Google开源的 AutoValue 框架，它会自动替你生成这些方法，通过类的单个注解就能触发。

​		

​		**总而言之不要轻易覆盖 equals 方法，除非迫不得已，覆盖也要准守 equals 合约的五个条款。**



#### 第11条：覆盖equals时总要覆盖hashCode

​		在每个覆盖了equals方法的类中，都必须覆盖 hashCode 方法。如果不这样做就会违反 hashCode 通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这类集合包括 HashMap 和 HashSet 。

​		不要试图从散列码计算中排除掉一个对象的关键域来提高性能。可以缓存在对象内部

​		不要对hashCode方法的返回值做出具体的规定，因此客户端无法理所当然的依赖它，这样可以为修改提供灵活性。





#### 第12条：始终要覆盖toString

​		提供好的 toString 实现可以使类使用起来更加舒适，使用了这个类的系统也更易于调试。

​		在实际应用中，toString 方法应该返回对象中所包含的**所有**值得关注的信息。

​		无论是否决定指定格式，都应该在文档中明确的表明你的意图。



#### 第13条：谨慎地覆盖clone

​		不可变的类永远都不应该提供clone方法

​		实际上，clone方法就是另外一个构造器；必须确保它不会伤害到原始的对象，并确保正确地被克隆对象中的约束条件。最容易的做法就是递归地调用clone

​		Cloneable 架构与引用可变对象的 final 域的正常用法是不相兼容的

​		对象拷贝的更好的办法是提供一个拷贝构造器或拷贝工厂



#### 第14条：考虑实现 Comparable 接口

​		每当实现一个对排序敏感的类时，都应该让这个类实现 Comparable 接口，以便其实例可以轻松的被分类、搜索，以及在集合中比较，每当在 compareTo 方法的实现中比较域值时，都要避免使用< 和 >操作符，二应该在装箱基本类型的类中，使用静态的 compare 方法，或者在 Comparator 接口中比较构造方法。



## 第4章 类和接口

### 第15条：使类的成员的可访问性最小化

##### 尽可能地使每个类或者成员不被外界访问

对于成员（域、方法、嵌套类和嵌套接口）有四种可能的访问级别

- 私有的
- 包级私有的
- 受保护的
- 公有的

​    公有类的实例域决不能是公有的（除非final），或者是可变对象的final引用，包含公有可变域的类通常并不是线程安全的。

​	让类具有公有的静态final数据域，或者返回这种域的访问方法，这是错误的。

~~~java
// Potential security hold!
public static final Thing[] Values = {....};

//改为以下正确
private static final Thing[] Values = {...};
public static final List<Thing> PRIVATE_VALUES =     Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

//或者
public static final Thing[] values(){
    return PRIVATE_VALUES.clone();
}
~~~

​		总之，应该始终尽肯能（合理）地降低程序元素的可访问性。在仔细地设计了一个最小公有API之后，应该放置把任何散乱的类、接口或者成员变成API的一部分。除了公有静态final域的特殊情形之外（此时它们应该充当常量），公有类不应该包含公有域，并且要确保公有静态final域所引用的对象都是不可变的。





### 第16条：要在公有类而非公有域中使用访问方法

​		简而言之，公有类永远都不应该暴露可变的域。虽然还是有问题，但是让公有类暴露不可变的域，其危害相对来说较小。有时候还是需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变的还是不可变的。



### 第17条：使可变性最小化

为了使类称为不可变，要遵循下面的五条规则：

- 不要提供任何会修改对象状态的方法（也称为设值方法）
- 保证类不会被拓展
- 声明所有的域都是final的
- 声明所有的域都为私有的
- 确保对于任何可变组件的互斥访问

​    Complex类的这些函数做运算后返回的是新的实例，而不是修改这个实例。大多数重要的不可变类都使用了这种模式，它被称为函数的方法，因为这些方法返回了一个函数的结果，而不是修改它。与之对应的场景的是过程的，或者命令式的。将一个过程作用在它们的操作数上，会导致它的状态发生改变。这些方法都是介词，如（plus），而不是动词（如add）

​		不可变对象比较简单。不可变对象只有一种状态，即被创建时的状态。可以确保在生命周期内永远不再发生变化，可变对象可以有任意复杂的状态空间，使用起来可靠性很差。

​		不可变对象本质上是线程安全的，它们不要求同步。

​		不可变的类，提供一些静态工厂，它们把频繁被请求的实例缓存起来。

​		不仅可以共享不可变对象，甚至可以共享它们内部信息。

​		为其他对象提供了大量的构件

​		无偿地提供了失败的原子性

​		不可变类的缺点，每一个值都需要一个单独的对象

​		不可变类可以弄成类的private也可以让构造器私有或包级私有然后提供金泰工厂来代替公有构造器



​		总之不要为每个get方法编写set方法，除非有很好的理由让类成为可变的类，否则它就一个是不可变的。

​		除非有令人信服的理由要使域变成是非final的，否则要使每个域都是private final的。

​		构造器应该创建完全初始化的对象，并建立起所有的约束关系。





### 第18条：复合优先于继承

​		与方法调用不同的是，继承打破了封装性

​		简而言之，继承的功能非常强大，但是也存在诸多问题，它违背了封装原则，只有当超类和子类之间确实存在子类型关系时使用继承才是恰当的。



### 第19条：要么设计继承并提供文档说明，要么禁止继承

​		该类必须有文档说明它可覆盖的方法的自用性

​		对于为了继承而设计的类，唯一的测试方法就是编写子类

​		**构造器决不能调用可被覆盖的方法**

​		**无论是clone 还是 readObject ，都不可以调用可覆盖的方法，**不管是以直接还是间接的方式





### 第20条：接口优于抽象类

​		现有的类可以很容易的被更新，以实现新的接口



























