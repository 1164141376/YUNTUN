## 第1章

​		引言：

​			组件的用户不该被其行为所迷惑，组件尽可能小，单不能太小，组件指任何可以重用的软件元素（单个方法，或则多个包的复杂框架）

​		代码应该被重用、而不是被拷贝，组件之间的依赖性应该尽可能降到最小

​		

​		Java支持的四种类型：接口、类、数组、基本数据类型（前三种为引用类型）



## 第2章 创建和销毁对象

#### 	第1条：用静态工厂方法代替构造函器

​		静态工厂方法与构造器不同的第一大优势，它们有名字。**调用更加清晰**

​		第二大优势，不必每次调用它们的时候都创建一个新的对象

​		第三大优势，可以灵活的返回原返回类型的任何子类型的对象

​		第四大优势，返回对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值。

​		第五大优势，方法返回的对象所属的类，在编写包含该静态工厂方法的类的时候可以不存在。

​		第一个缺点，类如果不包含共有的或者受保护的构造器，就不能被子类化。

​		第二个缺点，程序员很难发现它们



#### 第2条：遇到多个构造器参数时要考虑使用构造器

​		如果类的构造器或者静态工厂中具有多个参数，设计这种类的时候，Builder模式是一个不错的选择



#### 第3条：用私有构造器或者枚举类强化Singleton属性

​		使类成为Singleton会使它的客户端测试变得十分困难

​		1.使Field域公有并且final

​		2.静态工厂，使Field域私有并且final提供获取实例的公共静态方法

​		3.可以编写一个泛型Singleton工厂

​		优缺点：

​		1.公有域的优势在于，API很清楚的表明了这个类是一个Singleton

​		2.静态工厂方法的优势之一在于，它提供了灵活性：在不改变API的前提下，可以改变这个类是否应该是Singleton的想法。

​			可以通过方法引用作为提供者

​		3.单元素的枚举类型经常成为实现Singleton的最佳方法，如果Singleton必须拓展一个超类，而不是拓展Enum的时候就不宜使用这个方法。

​		

#### 第4条：通过私有构造器强化不可实例化的能力

​		有的时候需要编写包含静态方法和静态域的类。这样的类不希望被实例化，在缺省构造器的情况下会自动提供一个公有、无参的缺省构造器

​		企图通过将类做成抽象类来强制该类不可被实例化是**行不通**的。

​		让这个类包含一个私有构造器，它就不能被实例化

~~~java
//Noninstantiable utility class
public class UtilityClass{
    //Suppress default constructor for noninstantiability
    private UtilityClass(){
        throw new AssertionError();
    }
 	....// Remainder omitted
}
~~~



#### 第5条：有限考虑依赖注入来引用资源

​		不要用Singleton和静态工具类实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为，也不要直接用这个类来创建这些资源，而应该将这些资源或工厂传给构造器（或者静态工厂，或者构造器），通过它们来创建类。这个就叫做依赖注入它极大的提升了类的**灵活性、可重用性和可测试性**。



#### 第6条：避免创建不必要的对象

​		要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱

​		“保护性拷贝”的情况下，重用对象的代价要比创建新的重复对象要大



#### 第7条：消除过期的对象引用

















​		







